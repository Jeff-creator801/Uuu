<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Шашки — дамка скользящая, Undo, Double Capture</title>
<style>
  :root{--light:#eeeed2;--dark:#769656;--bg:#f4f7f9;}
  *{box-sizing:border-box}
  body{font-family:Inter,Helvetica,Arial,sans-serif;background:var(--bg);margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
  .game-wrap{width:760px;max-width:100%}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  #status{font-size:14px;color:#333}
  /* Меню */
  #menu{
    margin-bottom:12px;background:white;padding:12px;border-radius:10px;
    box-shadow:0 6px 18px rgba(20,30,50,0.06);display:flex;gap:12px;align-items:center;
  }
  .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn-primary{background:#2563eb;color:#fff}
  .btn-ghost{background:transparent;border:1px solid #cbd5e1;color:#111}
  .btn-mode{padding:8px 10px;border-radius:8px;border:1px solid transparent;cursor:pointer}
  .btn-mode.active{background:#111827;color:#fff}
  /* Layout */
  .main{display:flex;gap:18px;align-items:flex-start}
  /* Доска */
  #board-wrap{background:white;padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,50,0.06)}
  #board{
    width:560px;height:560px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);
    border-radius:8px;overflow:hidden;border:4px solid #2b3440;background:#222;
  }
  .cell{display:flex;align-items:center;justify-content:center;font-size:22px;user-select:none}
  .cell.light{background:var(--light)}
  .cell.dark{background:var(--dark)}
  .cell:hover{filter:brightness(1.03)}
  .piece{
    width:68%;height:68%;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;
    box-shadow:0 2px 5px rgba(0,0,0,0.25);cursor:pointer;
  }
  .piece.red{background:#e11d48;color:#fff}
  .piece.black{background:#111827;color:#fff}
  .piece.king{outline:3px solid gold}
  .selected{outline:4px solid rgba(255,255,0,0.9);outline-offset:-6px}
  .highlight{box-shadow: inset 0 0 0 6px rgba(255,255,0,0.12)}
  /* Controls column */
  .controls{width:180px;display:flex;flex-direction:column;gap:8px}
  .small{font-size:13px;color:#374151}
  .muted{font-size:13px;color:#6b7280}
  .btn-block{width:100%}
  @media(max-width:900px){
    .main{flex-direction:column;align-items:center}
    #board{width:360px;height:360px}
    .controls{width:100%;display:flex;flex-direction:row;justify-content:space-between}
  }
</style>
</head>
<body>
  <div class="game-wrap">
    <header>
      <h1>Шашки (с дамкой-скользящей)</h1>
      <div id="status">Выберите режим и нажмите «Начать игру»</div>
    </header>

    <!-- Меню -->
    <div id="menu">
      <div style="display:flex;gap:8px;align-items:center;">
        <div>Играть против:</div>
        <button class="btn-mode" id="modeFriend">Друг</button>
        <button class="btn-mode" id="modeAI">ИИ</button>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px">
        <button class="btn btn-primary" id="startBtn">Начать игру</button>
        <button class="btn btn-ghost" id="newBtn">Новая игра</button>
      </div>
    </div>

    <div class="main">
      <div id="board-wrap">
        <div id="board" aria-label="Шашечная доска"></div>
      </div>

      <div class="controls">
        <div><button class="btn btn-ghost btn-block" id="undoBtn">Ход назад (Undo)</button></div>
        <div class="small"><b>Подсказки:</b></div>
        <div class="muted">• Дамка ходит по диагонали на любое расстояние.</div>
        <div class="muted">• При захвате дамка может прыгнуть через противника и приземлиться на любую пустую клетку за ним.</div>
        <div class="muted">• Многопрыжки поддерживаются для всех фишек. Если захват возможен — он обязателен.</div>
        <div style="margin-top:auto" class="small">ИИ отдаёт приоритет съеданиям (ищет максимальное число съедаемых фигур).</div>
      </div>
    </div>
  </div>

<script>
/* Модель:
 boardState[r][c] = null | { color: 'red'|'black', king: boolean }
 currentPlayer: 'red'|'black'
 historyStack: массив снимков состояния для Undo
 gameMode: 'friend'|'ai'
 selected: {r,c} или null
 midCapture: bool - если в середине цепочки захватов (игрок обязан продолжать той же фишкой)
*/

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const modeFriendBtn = document.getElementById('modeFriend');
const modeAIBtn = document.getElementById('modeAI');
const startBtn = document.getElementById('startBtn');
const newBtn = document.getElementById('newBtn');
const undoBtn = document.getElementById('undoBtn');

let gameMode = null;
let gameStarted = false;
let boardState = [];
let currentPlayer = 'red';
let selected = null;
let historyStack = [];
let midCapture = false;

modeFriendBtn.addEventListener('click', ()=> chooseMode('friend'));
modeAIBtn.addEventListener('click', ()=> chooseMode('ai'));
startBtn.addEventListener('click', startGame);
newBtn.addEventListener('click', resetToMenu);
undoBtn.addEventListener('click', undoMove);

chooseMode('friend');

/* UI mode */
function chooseMode(m){
  gameMode = m;
  modeFriendBtn.classList.toggle('active', m==='friend');
  modeAIBtn.classList.toggle('active', m==='ai');
  statusEl.textContent = 'Режим: ' + (m==='friend' ? 'Против друга' : 'Против ИИ') + ' — нажмите «Начать игру»';
}

/* Инициализация начальной доски */
function initBoardState(){
  boardState = Array.from({length:8}, ()=>Array(8).fill(null));
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      if((r+c)%2 === 1){
        if(r < 3) boardState[r][c] = {color:'black', king:false};
        else if(r > 4) boardState[r][c] = {color:'red', king:false};
      }
    }
  }
}

/* Отрисовка */
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const cell = document.createElement('div');
      cell.className = 'cell ' + (((r+c)%2===0) ? 'light' : 'dark');
      cell.dataset.r = r; cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      const piece = boardState[r][c];
      if(piece){
        const p = document.createElement('div');
        p.className = 'piece ' + piece.color + (piece.king ? ' king' : '');
        p.textContent = piece.king ? '♔' : '';
        cell.appendChild(p);
      }
      boardEl.appendChild(cell);
    }
  }
  updateSelectionVisual();
  updateStatus();
}

/* Запуск игры */
function startGame(){
  if(!gameMode) return alert('Выберите режим игры.');
  initBoardState();
  gameStarted = true;
  currentPlayer = 'red';
  selected = null;
  historyStack = [];
  midCapture = false;
  renderBoard();
  modeFriendBtn.disabled = true;
  modeAIBtn.disabled = true;
  startBtn.disabled = true;
  statusEl.textContent = (gameMode==='ai' ? 'Режим: ИИ. ' : 'Режим: Друг. ') + 'Ходят красные.';
}

/* Сброс в меню */
function resetToMenu(){
  gameStarted = false;
  initBoardState();
  renderBoard();
  modeFriendBtn.disabled = false;
  modeAIBtn.disabled = false;
  startBtn.disabled = false;
  statusEl.textContent = 'Выберите режим и нажмите «Начать игру»';
  selected = null;
  historyStack = [];
  midCapture = false;
}

/* Клик по клетке */
function onCellClick(e){
  if(!gameStarted) return;
  const r = parseInt(e.currentTarget.dataset.r,10);
  const c = parseInt(e.currentTarget.dataset.c,10);
  const clickedPiece = boardState[r][c];

  // Если в середине цепочки — можно двигать только той же фишкой и только захватывать
  if(midCapture){
    if(selected && selected.r === r && selected.c === c){
      updateSelectionVisual(); return;
    }
    if(selected && isValidCaptureStep(selected.r, selected.c, r, c)){
      performStep(selected.r, selected.c, r, c);
      return;
    } else return; // запрещаем выбирать другие клетки/фигуры
  }

  // Если уже выбрано
  if(selected){
    // попытка выполнить ход (может быть capture или обычный ход)
    const move = findMoveForSelection(selected.r, selected.c, r, c);
    if(move){
      // если это многократная capture начнётся, performStep об этом позаботится
      performStep(selected.r, selected.c, r, c);
      return;
    } else {
      // если кликнули на свою фишку — сменить выбор (но учитывать forced captures)
      if(clickedPiece && clickedPiece.color === currentPlayer){
        const forced = getAllCaptureMoves(currentPlayer);
        if(forced.length > 0){
          const hasCapture = getCaptureMovesForPiece(r,c).length > 0;
          if(!hasCapture) { selected = null; updateSelectionVisual(); return; }
        }
        selected = {r,c}; updateSelectionVisual(); return;
      }
      selected = null; updateSelectionVisual(); return;
    }
  } else {
    // выбрать свою фишку (если у неё есть ходы). Если есть forced captures, разрешаем выбирать только те, у кого есть capture
    if(clickedPiece && clickedPiece.color === currentPlayer){
      const forced = getAllCaptureMoves(currentPlayer);
      if(forced.length > 0){
        if(getCaptureMovesForPiece(r,c).length === 0) return; // нельзя выбрать
      } else {
        if(getAllMovesForPiece(r,c).length === 0) return; // нечего выбрать
      }
      selected = {r,c}; updateSelectionVisual(); return;
    }
  }
}

/* === Вспомогательная логика хода и генерация ходов === */

function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function opponentOf(color){ return color === 'red' ? 'black' : 'red'; }

/* Возвращает ВСЕ ходы (включая захваты) для игрока color.
   Каждый ход — объект: { sr, sc, dr, dc, capture: bool, captured?: {r,c} }
   Для дамки не-капа — будут все возможные скользящие клетки.
   Для дамки-капа — первый шаг (capture) для каждого возможного landing (после одного перепрыгивания).
   Многопрыжки обрабатываются динамически: после первого шага мы проверяем дальнейшие capture-ходы.
*/
function getAllMoves(color){
  let res = [];
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = boardState[r][c];
      if(p && p.color === color){
        const moves = getAllMovesForPiece(r,c);
        for(const m of moves) res.push({sr:r,sc:c,dr:m.dr,dc:m.dc,capture:m.capture, captured: m.captured || null});
      }
    }
  }
  // если есть захваты — фильтруем простые ходы
  const caps = res.filter(m => m.capture);
  return caps.length > 0 ? caps : res;
}

/* Возвращает массив возможных ходов (первый шаг) для конкретной фишки */
function getAllMovesForPiece(r,c){
  const p = boardState[r][c];
  if(!p) return [];
  if(p.king) return getKingMoves(r,c);
  return getManMoves(r,c);
}

/* Обычная шашка (не дамка): соседние шаги и обычные захваты (вперед для шага, захват вперед; можно разрешить назад для захвата? в этой реализации — захват назад запрещён для манов, как в классике) */
function getManMoves(r,c){
  const p = boardState[r][c];
  const res = [];
  const forward = p.color === 'red' ? -1 : 1;
  const simpleDirs = [[forward, -1],[forward, 1]];
  for(const [dr,dc] of simpleDirs){
    const nr = r + dr, nc = c + dc;
    if(inBounds(nr,nc) && boardState[nr][nc] === null){
      res.push({dr:nr, dc:nc, capture:false});
    }
  }
  // захваты - проверяем все 4 диагонали (по правилам: для мана захват вперёд, но некоторые правила разрешают назад; здесь разрешим захваты и назад для простоты как в многих реализациях)
  const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const [dr,dc] of diag){
    const mr = r + dr, mc = c + dc;
    const tr = r + dr*2, tc = c + dc*2;
    if(inBounds(tr,tc) && boardState[tr][tc] === null){
      const mid = boardState[mr] && boardState[mr][mc];
      if(mid && mid.color !== p.color){
        // можно добавить условие про направление, но оставим захват назад разрешённым (более гибкие правила)
        res.push({dr:tr, dc:tc, capture:true, captured:{r:mr,c:mc}});
      }
    }
  }
  return res;
}

/* Дамка (скользящая) — возвращаем:
   - все простые (не-capture) скольжения по диагонали до первой занятой клетки.
   - все возможные первые-step captures: для каждой диагонали ищем противника, за ним все пустые клетки (landing) => для каждого landing добавляем capture с captured coord.
*/
function getKingMoves(r,c){
  const p = boardState[r][c];
  const res = [];
  const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
  // скольжение (простой ход)
  for(const [dr,dc] of dirs){
    let nr = r + dr, nc = c + dc;
    while(inBounds(nr,nc) && boardState[nr][nc] === null){
      res.push({dr:nr, dc:nc, capture:false});
      nr += dr; nc += dc;
    }
  }
  // захваты: ищем ближайшую в диагонали фигуру противника (может быть на разном расстоянии),
  // за ней — любые пустые клетки до следующей занятой или края доски
  for(const [dr,dc] of dirs){
    let nr = r + dr, nc = c + dc;
    let foundEnemy = false;
    while(inBounds(nr,nc)){
      const cell = boardState[nr][nc];
      if(!foundEnemy){
        if(cell === null){ nr += dr; nc += dc; continue; }
        if(cell && cell.color === p.color) break; // своя фигура блокирует
        if(cell && cell.color !== p.color){
          // нашли первую в диагонали вражескую фигуру — теперь за ней должны быть пустые клетки для landing
          foundEnemy = true;
          // scan landing squares
          let lr = nr + dr, lc = nc + dc;
          while(inBounds(lr,lc) && boardState[lr][lc] === null){
            res.push({dr:lr, dc:lc, capture:true, captured:{r:nr,c:nc}});
            lr += dr; lc += dc;
          }
          break; // после первой вражеской фигуры дальше нет других capture по той диагонали для первого шага
        }
      }
    }
  }
  return res;
}

/* Возвращает только capture-ходы для данной фишки (первый шаг) */
function getCaptureMovesForPiece(r,c){
  return getAllMovesForPiece(r,c).filter(m => m.capture);
}

/* Возвращает все capture-ходы для цвета (используется для forced-capture логики) */
function getAllCaptureMoves(color){
  return getAllMoves(color).filter(m => m.capture);
}

/* Найти move-объект по выбранной паре клеток (учитывая available moves) */
function findMoveForSelection(sr,sc,dr,dc){
  const moves = getAllMoves(currentPlayer);
  return moves.find(m => m.sr === sr && m.sc === sc && m.dr === dr && m.dc === dc) || null;
}

/* Проверяет, является ли (sr,sc)->(dr,dc) допустимым capture-шагом (используется при midCapture) */
function isValidCaptureStep(sr,sc,dr,dc){
  const caps = getCaptureMovesForPiece(sr,sc);
  return caps.some(m => m.dr === dr && m.dc === dc);
}

/* Сохранить snapshot (глубокая копия) перед атомарным шагом */
function pushHistory(){
  const snap = {
    board: JSON.parse(JSON.stringify(boardState)),
    currentPlayer,
    selected: selected ? {r:selected.r,c:selected.c} : null,
    midCapture
  };
  historyStack.push(snap);
  if(historyStack.length > 400) historyStack.shift();
}

/* Откат */
function undoMove(){
  if(historyStack.length === 0) return;
  const snap = historyStack.pop();
  boardState = JSON.parse(JSON.stringify(snap.board));
  currentPlayer = snap.currentPlayer;
  selected = snap.selected ? {r:snap.selected.r,c:snap.selected.c} : null;
  midCapture = snap.midCapture;
  gameStarted = true;
  renderBoard();
}

/* Выполнить один атомарный шаг (шаг или захват).
   После шага:
     - если был захват и после него есть дальнейшие захваты той же фигурой -> midCapture = true, оставляем currentPlayer тем же и selected на новом месте
     - иначе -> midCapture = false, смена игрока
*/
function performStep(sr,sc,dr,dc){
  // найти move-объект (чтобы получить координаты captured для дамки)
  const move = findMoveForSelection(sr,sc,dr,dc);
  if(!move) return;
  pushHistory(); // сохранить состояние до атомарного шага

  const piece = boardState[sr][sc];
  const wasCapture = move.capture === true;
  // переместить
  boardState[dr][dc] = {...piece};
  boardState[sr][sc] = null;

  if(wasCapture){
    let cr = move.captured.r, cc = move.captured.c;
    // Для манов captured уже указан. Для дамки мы also included captured coordinate in move above.
    // Удаляем съеденную фигуру:
    boardState[cr][cc] = null;
  }

  // коронация: если ман дошёл до конца
  if(boardState[dr][dc].color === 'red' && dr === 0) boardState[dr][dc].king = true;
  if(boardState[dr][dc].color === 'black' && dr === 7) boardState[dr][dc].king = true;

  // если захват — проверить дальнейшие захваты от новой позиции
  if(wasCapture){
    const further = getCaptureMovesForPiece(dr,dc);
    if(further.length > 0){
      // остаёмся у того же игрока и обязаны продолжать той же фигурой
      midCapture = true;
      selected = {r:dr,c:dc};
      renderBoard();
      // если ИИ — автоматизировать продолжение (выбираем лучший capture по евристике)
      if(gameMode === 'ai' && currentPlayer === 'black'){
        setTimeout(()=> aiContinueCapture(dr,dc), 200);
      } else {
        statusEl.textContent = (currentPlayer === 'red' ? 'Красные' : 'Чёрные') + ' — продолжите цепочку захватов';
      }
      return;
    }
  }

  // иначе цепочка закончилась или вообще не было захвата
  midCapture = false;
  selected = null;
  // смена игрока
  currentPlayer = opponentOf(currentPlayer);
  renderBoard();

  if(gameMode === 'ai' && currentPlayer === 'black'){
    setTimeout(aiMove, 200);
  }
}

/* ИИ: выбирает лучший capture (максимум съедаемых) или обычный ход если capture нет.
   Для оценки capture-цепочек используем симуляцию (рекурсивный поиск максимального количества захватов).
*/

function aiMove(){
  if(!gameStarted) return;
  // собрать все возможные ходы для black
  const moves = getAllMoves('black');
  if(moves.length === 0){
    setTimeout(()=> alert('Красные победили!'),50);
    gameStarted = false;
    modeFriendBtn.disabled = false; modeAIBtn.disabled = false; startBtn.disabled = false;
    return;
  }

  // выделим capture-ходы
  const captureMoves = moves.filter(m => m.capture);
  if(captureMoves.length > 0){
    // Для каждого capture-хода посчитаем максимальное число фигур, которые можно съесть, если выполнить этот шаг (симуляция)
    const scored = captureMoves.map(m => {
      const copy = JSON.parse(JSON.stringify(boardState));
      // выполнить атомарный шаг на копии
      copy[m.dr][m.dc] = {...copy[m.sr][m.sc]}; copy[m.sr][m.sc] = null;
      const cr = m.captured.r, cc = m.captured.c; copy[cr][cc] = null;
      // если коронация возможна — учтём, дамка в копии
      if(copy[m.dr][m.dc].color === 'black' && m.dr === 7) copy[m.dr][m.dc].king = true;
      const maxFurther = simulateMaxCaptures(copy, m.dr, m.dc);
      return {move: m, score: 1 + maxFurther}; // 1 за этот capture + дальнейшие
    });
    // выбрать max score
    const maxScore = Math.max(...scored.map(s=>s.score));
    const best = scored.filter(s => s.score === maxScore).map(s=>s.move);
    const chosen = best[Math.floor(Math.random()*best.length)];
    performStep(chosen.sr, chosen.sc, chosen.dr, chosen.dc);
    return;
  }

  // иначе — обыч ход: выбрать случайный простой ход (или можно подобрать эвристикой)
  const simple = moves.filter(m=>!m.capture);
  const chosen = simple[Math.floor(Math.random()*simple.length)];
  performStep(chosen.sr, chosen.sc, chosen.dr, chosen.dc);
}

/* Симуляция: возвращает максимальное число дополнительных фигур, которые можно съесть начиная с позиции (r,c) на boardCopy.
   (используется для оценки capture-цепочек ИИ) */
function simulateMaxCaptures(boardCopy, r, c){
  // рекурсивный поиск максимумов. Мы создаём локальную функцию, чтобы не ломать глобальную boardState.
  function inB(rr,cc){ return rr>=0 && rr<8 && cc>=0 && cc<8; }
  const piece = boardCopy[r][c];
  if(!piece) return 0;
  let best = 0;

  function kingFirstMoves(r0,c0){
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    const res = [];
    for(const [dr,dc] of dirs){
      let nr = r0 + dr, nc = c0 + dc;
      while(inB(nr,nc) && boardCopy[nr][nc] === null) { nr += dr; nc += dc; }
      if(inB(nr,nc) && boardCopy[nr][nc] && boardCopy[nr][nc].color !== piece.color){
        // landing squares beyond
        let lr = nr + dr, lc = nc + dc;
        while(inB(lr,lc) && boardCopy[lr][lc] === null){
          res.push({dr:lr, dc:lc, captured:{r:nr,c:nc}});
          lr += dr; lc += dc;
        }
      }
    }
    return res;
  }

  function manFirstMoves(r0,c0){
    const res = [];
    const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [dr,dc] of diag){
      const mr = r0 + dr, mc = c0 + dc;
      const tr = r0 + dr*2, tc = c0 + dc*2;
      if(inB(tr,tc) && boardCopy[tr][tc] === null){
        const mid = boardCopy[mr][mc];
        if(mid && mid.color !== piece.color) res.push({dr:tr,dc:tc,captured:{r:mr,c:mc}});
      }
    }
    return res;
  }

  function dfs(r0,c0, boardLocal){
    let moves = [];
    if(boardLocal[r0][c0].king) moves = kingFirstMoves(r0,c0);
    else moves = manFirstMoves(r0,c0);
    if(moves.length === 0) return 0;
    let localBest = 0;
    for(const mv of moves){
      // copy local board
      const b2 = JSON.parse(JSON.stringify(boardLocal));
      // perform step
      b2[mv.dr][mv.dc] = {...b2[r0][c0]};
      b2[r0][c0] = null;
      const cr = mv.captured.r, cc = mv.captured.c;
      b2[cr][cc] = null;
      // if coronation for man -> set king true (rare in simulation)
      if(b2[mv.dr][mv.dc].color === 'black' && mv.dr === 7) b2[mv.dr][mv.dc].king = true;
      const further = dfs(mv.dr, mv.dc, b2);
      localBest = Math.max(localBest, 1 + further);
    }
    return localBest;
  }

  return dfs(r,c,boardCopy);
}

/* AI: если уже в середине цепочки (midCapture) и это ИИ, продолжает цепочку автоматически */
function aiContinueCapture(r,c){
  if(!gameStarted) return;
  const caps = getCaptureMovesForPiece(r,c);
  if(caps.length === 0){
    midCapture = false;
    selected = null;
    currentPlayer = opponentOf(currentPlayer);
    renderBoard();
    return;
  }
  // выбрать capture с наибольшей глубиной
  const scored = caps.map(m => {
    // simulate board
    const copy = JSON.parse(JSON.stringify(boardState));
    copy[m.dr][m.dc] = {...copy[m.sr][m.sc]}; copy[m.sr][m.sc] = null;
    const cr = m.captured.r, cc = m.captured.c; copy[cr][cc] = null;
    if(copy[m.dr][m.dc].color === 'black' && m.dr === 7) copy[m.dr][m.dc].king = true;
    return {move:m, score: 1 + simulateMaxCaptures(copy, m.dr, m.dc)};
  });
  const maxScore = Math.max(...scored.map(s=>s.score));
  const best = scored.filter(s=>s.score===maxScore).map(s=>s.move);
  const chosen = best[Math.floor(Math.random()*best.length)];
  performStep(chosen.sr, chosen.sc, chosen.dr, chosen.dc);
}

/* Проверка, есть ли хоть один ход у цвета (используется для конца игры) */
function hasAnyMovesForColor(color){
  return getAllMoves(color).length > 0;
}

/* Обновление статуса и подсказок */
function updateStatus(){
  if(!gameStarted){ statusEl.textContent = 'Игра не начата'; return; }
  if(midCapture){ statusEl.textContent = (currentPlayer==='red' ? 'Красные' : 'Чёрные') + ' — продолжите цепочку захватов'; return; }
  statusEl.textContent = (currentPlayer==='red' ? 'Ходят красные' : 'Ходят чёрные') + (gameMode==='ai' ? (currentPlayer==='black' ? ' (ИИ)' : '') : '');
}

/* Обновление визуальной подсветки выбранной клетки и доступных целей.
   Для capture-правила если есть захваты у любого — показываем только capture-цели (первые шаги).
*/
function updateSelectionVisual(){
  document.querySelectorAll('.cell').forEach(cell=>{
    cell.classList.remove('selected','highlight');
  });
  if(!selected) return;
  const selCell = document.querySelector(`.cell[data-r="${selected.r}"][data-c="${selected.c}"]`);
  if(selCell) selCell.classList.add('selected');

  // если midCapture — показываем только capture-цели для этой шашки
  if(midCapture){
    const caps = getCaptureMovesForPiece(selected.r, selected.c);
    for(const m of caps){
      const target = document.querySelector(`.cell[data-r="${m.dr}"][data-c="${m.dc}"]`);
      if(target) target.classList.add('highlight');
    }
    return;
  }

  // если в игре есть захваты — показываем только capture-цели для выбранной фигуры (если у неё есть)
  const allCaps = getAllCaptureMoves(currentPlayer);
  if(allCaps.length > 0){
    const caps = getCaptureMovesForPiece(selected.r, selected.c);
    for(const m of caps){
      const target = document.querySelector(`.cell[data-r="${m.dr}"][data-c="${m.dc}"]`);
      if(target) target.classList.add('highlight');
    }
    return;
  }

  // иначе показываем все ходы (включая скольжения дамки)
  const moves = getAllMovesForPiece(selected.r, selected.c);
  for(const m of moves){
    const target = document.querySelector(`.cell[data-r="${m.dr}"][data-c="${m.dc}"]`);
    if(target) target.classList.add('highlight');
  }
}

/* Найти capture-мoves для конкретной позиции (deprecated wrapper, но удобно) */
function getCaptureMovesForPieceWrapper(r,c){
  return getCaptureMovesForPiece(r,c);
}

/* Найти move по координатам — для манипуляций (в т.ч. performStep использует findMoveForSelection) */
function findMoveForSelection(sr,sc,dr,dc){
  const moves = getAllMoves(currentPlayer);
  return moves.find(m => m.sr === sr && m.sc === sc && m.dr === dr && m.dc === dc) || null;
}

/* Инициализация при загрузке */
initBoardState();
renderBoard();

</script>
</body>
</html>
