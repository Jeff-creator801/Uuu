<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Шашки — играть против друга / ИИ</title>
<style>
  :root{--light:#eeeed2;--dark:#769656;--bg:#f4f7f9;}
  *{box-sizing:border-box}
  body{font-family:Inter,Helvetica,Arial,sans-serif;background:var(--bg);margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
  .game-wrap{width:700px;max-width:100%}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  #status{font-size:14px;color:#333}
  /* Меню поверх игры */
  #menu{
    position:relative;
    margin-bottom:12px;
    background:white;
    padding:14px;
    border-radius:10px;
    box-shadow:0 6px 18px rgba(20,30,50,0.08);
    display:flex;
    gap:12px;
    align-items:center;
  }
  .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn-primary{background:#2563eb;color:#fff}
  .btn-ghost{background:transparent;border:1px solid #cbd5e1;color:#111}
  .btn-mode{padding:8px 10px;border-radius:8px;border:1px solid transparent;cursor:pointer}
  .btn-mode.active{background:#111827;color:#fff}
  /* Доска */
  #board{
    width:480px;height:480px;max-width:100%;aspect-ratio:1/1;
    display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);
    border-radius:8px;overflow:hidden;border:4px solid #2b3440;background:#222;
    margin:0 auto;
  }
  .cell{display:flex;align-items:center;justify-content:center;font-size:22px;user-select:none}
  .cell.light{background:var(--light)}
  .cell.dark{background:var(--dark)}
  .cell:hover{filter:brightness(1.03)}
  .piece{
    width:68%;height:68%;border-radius:50%;display:flex;align-items:center;justify-content:center;
    font-weight:700;box-shadow:0 2px 5px rgba(0,0,0,0.25);cursor:pointer;
  }
  .piece.red{background:#e11d48;color:#fff}
  .piece.black{background:#111827;color:#fff}
  .piece.king{outline:3px solid gold}
  .selected{outline:4px solid rgba(255,255,0,0.85);outline-offset:-6px}
  .highlight{box-shadow: inset 0 0 0 4px rgba(255,255,0,0.14)}
  /* Подсказки снизу */
  footer{margin-top:12px;text-align:center;color:#374151;font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  @media(max-width:640px){
    #board{width:360px;height:360px}
  }
</style>
</head>
<body>
<div class="game-wrap">
  <header>
    <h1>Шашки</h1>
    <div id="status">Выберите режим и нажмите «Начать игру»</div>
  </header>

  <!-- Меню выбора режима -->
  <div id="menu">
    <div style="display:flex;gap:8px;align-items:center;">
      <div>Играть против:</div>
      <button class="btn-mode" id="modeFriend">Друг</button>
      <button class="btn-mode" id="modeAI">ИИ</button>
    </div>

    <div style="margin-left:auto;display:flex;gap:8px">
      <button class="btn btn-primary" id="startBtn">Начать игру</button>
      <button class="btn btn-ghost" id="newBtn">Новая игра</button>
    </div>
  </div>

  <!-- Игровая доска -->
  <div id="board" aria-label="Шашечная доска"></div>

  <footer>
    <div class="controls">
      <div style="min-width:220px;text-align:left;color:#374151;font-size:13px">
        <b>Правила:</b> красные ходят первыми. Дамка отмечается золотой окантовкой. Во время партии режим менять нельзя.
      </div>
    </div>
  </footer>
</div>

<script>
/* Представление клетки: null или {color:'red'|'black', king: boolean} */
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const modeFriendBtn = document.getElementById('modeFriend');
const modeAIBtn = document.getElementById('modeAI');
const startBtn = document.getElementById('startBtn');
const newBtn = document.getElementById('newBtn');

let gameMode = null; // 'friend' или 'ai'
let gameStarted = false;
let boardState = [];
let selected = null; // {r,c}
let currentPlayer = 'red';

// UI: выбор режима кнопки
modeFriendBtn.addEventListener('click', ()=> chooseMode('friend'));
modeAIBtn.addEventListener('click', ()=> chooseMode('ai'));
startBtn.addEventListener('click', startGame);
newBtn.addEventListener('click', resetToMenu);

chooseMode('friend'); // по умолчанию

function chooseMode(m){
  gameMode = m;
  modeFriendBtn.classList.toggle('active', m==='friend');
  modeAIBtn.classList.toggle('active', m==='ai');
  statusEl.textContent = 'Режим выбран: ' + (m==='friend' ? 'Против друга' : 'Против ИИ') + ' — нажмите "Начать игру"';
}

/* Инициализация доски в память и отрисовка */
function initBoardState(){
  boardState = Array.from({length:8}, ()=>Array(8).fill(null));
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      if((r+c)%2 === 1){
        if(r < 3) boardState[r][c] = {color:'black', king:false};
        else if(r > 4) boardState[r][c] = {color:'red', king:false};
      }
    }
  }
}

/* Отрисовка DOM доски по boardState */
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const cell = document.createElement('div');
      cell.className = 'cell ' + (((r+c)%2===0) ? 'light' : 'dark');
      cell.dataset.r = r; cell.dataset.c = c;
      // добавляем слушатель
      cell.addEventListener('click', onCellClick);
      const piece = boardState[r][c];
      if(piece){
        const p = document.createElement('div');
        p.className = 'piece ' + piece.color + (piece.king ? ' king' : '');
        p.textContent = piece.king ? '♔' : '';
        cell.appendChild(p);
      }
      boardEl.appendChild(cell);
    }
  }
  updateSelectionVisual();
}

/* Начать игру */
function startGame(){
  if(!gameMode) return alert('Выберите режим игры.');
  initBoardState();
  gameStarted = true;
  currentPlayer = 'red';
  selected = null;
  renderBoard();
  // блокируем выбор режима (визуально)
  modeFriendBtn.disabled = true;
  modeAIBtn.disabled = true;
  startBtn.disabled = true;
  statusEl.textContent = (gameMode==='ai' ? 'Режим: ИИ. ' : 'Режим: Друг. ') + 'Ходят красные.';
  // если ИИ должен ходить первым — в наших правилах красные всегда первые, так что нет
}

/* Вернуться в меню (новая игра) */
function resetToMenu(){
  gameStarted = false;
  initBoardState();
  renderBoard();
  modeFriendBtn.disabled = false;
  modeAIBtn.disabled = false;
  startBtn.disabled = false;
  statusEl.textContent = 'Выберите режим и нажмите «Начать игру»';
  selected = null;
}

/* Обработчик клика по клетке */
function onCellClick(e){
  if(!gameStarted) return;
  const r = parseInt(e.currentTarget.dataset.r,10);
  const c = parseInt(e.currentTarget.dataset.c,10);
  const cellPiece = boardState[r][c];

  // Если уже выбрана фигура
  if(selected){
    // Попытка хода выбранной фигурой в (r,c)
    if(isValidMove(selected.r, selected.c, r, c)){
      doMove(selected.r, selected.c, r, c);
      selected = null;
      renderBoard();
      // Проверка на конец игры
      if(!hasAnyMovesForColor(opponentOf(currentPlayer))){
        setTimeout(()=> alert((currentPlayer === 'red' ? 'Красные' : 'Чёрные') + ' победили!'), 50);
        gameStarted = false;
        statusEl.textContent = 'Игра окончена';
        // разблокировать режимы
        modeFriendBtn.disabled = false; modeAIBtn.disabled = false; startBtn.disabled = false;
        return;
      }
      // Смена игрока
      currentPlayer = opponentOf(currentPlayer);
      statusEl.textContent = (currentPlayer === 'red' ? 'Ходят красные' : 'Ходят чёрные');
      // Если сейчас ход ИИ — запустить
      if(gameMode === 'ai' && currentPlayer === 'black'){
        setTimeout(aiMove, 250);
      }
      return;
    } else {
      // если кликнули не по доступной цели — снять выбор или выбрать другую свою шашку
      if(cellPiece && cellPiece.color === currentPlayer){
        selected = {r,c};
        updateSelectionVisual();
      } else {
        selected = null;
        updateSelectionVisual();
      }
      return;
    }
  } else {
    // Нет выбора — можно выбрать свою шашку
    if(cellPiece && cellPiece.color === currentPlayer){
      selected = {r,c};
      updateSelectionVisual();
    }
  }
}

/* Обновить визуальное выделение выбранной клетки и подсветка возможных ходов */
function updateSelectionVisual(){
  // очистка
  document.querySelectorAll('.cell').forEach(cell => {
    cell.classList.remove('selected','highlight');
  });
  if(!selected) return;
  const selCell = document.querySelector(`.cell[data-r="${selected.r}"][data-c="${selected.c}"]`);
  if(selCell) selCell.classList.add('selected');
  // подсветить возможные цели
  for(let dr=0; dr<8; dr++){
    for(let dc=0; dc<8; dc++){
      if(isValidMove(selected.r, selected.c, dr, dc)){
        const cell = document.querySelector(`.cell[data-r="${dr}"][data-c="${dc}"]`);
        if(cell) cell.classList.add('highlight');
      }
    }
  }
}

/* Валидация хода (не меняет boardState) */
function isValidMove(sr, sc, dr, dc){
  // общие проверки
  if(sr===dr && sc===dc) return false;
  if(!inBounds(sr,sc) || !inBounds(dr,dc)) return false;
  const piece = boardState[sr][sc];
  if(!piece) return false;
  if(boardState[dr][dc] !== null) return false; // цель должна быть пустой

  const dx = dc - sc;
  const dy = dr - sr;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  // движение по диагонали только
  if(absDx !== absDy) return false;

  // направление для некороля: red вверх (-1), black вниз (+1)
  const dir = (piece.color === 'red') ? -1 : 1;

  // простое движение на 1 шаг: допускается если король или направление совпадает
  if(absDx === 1 && absDy === 1){
    if(piece.king) return true;
    return dy === dir;
  }

  // прыжок через шашку (съедание)
  if(absDx === 2 && absDy === 2){
    const midR = (sr + dr) >> 1;
    const midC = (sc + dc) >> 1;
    const mid = boardState[midR][midC];
    if(mid && mid.color !== piece.color) {
      // Для некороля можно требовать направление прыжка, но классические правила позволяют прыжки назад для дамки только.
      if(piece.king) return true;
      return dy === dir * 2;
    }
  }

  return false;
}

/* Выполнить ход (модифицирует boardState). Возвращает true, если было съедание */
function doMove(sr, sc, dr, dc){
  const piece = boardState[sr][sc];
  if(!piece) return false;
  const jumped = Math.abs(sr - dr) === 2;
  // переместить
  boardState[dr][dc] = {...piece}; // копия объекта
  boardState[sr][sc] = null;
  if(jumped){
    const midR = (sr + dr) >> 1;
    const midC = (sc + dc) >> 1;
    boardState[midR][midC] = null;
  }
  // коронация
  if(boardState[dr][dc].color === 'red' && dr === 0) boardState[dr][dc].king = true;
  if(boardState[dr][dc].color === 'black' && dr === 7) boardState[dr][dc].king = true;

  return jumped;
}

/* ИИ: собирает все возможные ходы для чёрных и делает случайный */
function aiMove(){
  if(!gameStarted) return;
  // собираем все ходы
  const moves = [];
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = boardState[r][c];
      if(p && p.color === 'black'){
        for(let dr=0; dr<8; dr++){
          for(let dc=0; dc<8; dc++){
            if(isValidMove(r,c,dr,dc)) moves.push({sr:r,sc:c,dr,dc});
          }
        }
      }
    }
  }
  if(moves.length === 0){
    // ИИ не может ходить — красные победили
    setTimeout(()=> alert('Красные победили!'), 50);
    gameStarted = false;
    statusEl.textContent = 'Игра окончена';
    modeFriendBtn.disabled = false; modeAIBtn.disabled = false; startBtn.disabled = false;
    return;
  }

  // предпочтение: съедания выше простых ходов (простая эвристика)
  const captureMoves = moves.filter(m => Math.abs(m.sr - m.dr) === 2);
  const chosen = (captureMoves.length ? captureMoves : moves)[Math.floor(Math.random() * (captureMoves.length ? captureMoves.length : moves.length))];

  doMove(chosen.sr, chosen.sc, chosen.dr, chosen.dc);
  renderBoard();

  // проверить конец игры
  if(!hasAnyMovesForColor('red')){
    setTimeout(()=> alert('Чёрные победили!'), 50);
    gameStarted = false;
    statusEl.textContent = 'Игра окончена';
    modeFriendBtn.disabled = false; modeAIBtn.disabled = false; startBtn.disabled = false;
    return;
  }

  // смена игрока
  currentPlayer = 'red';
  statusEl.textContent = 'Ходят красные';
}

/* Вспомогательные */
function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function opponentOf(col){ return col === 'red' ? 'black' : 'red'; }

/* Проверяет, есть ли хоть один допустимый ход для цвета */
function hasAnyMovesForColor(color){
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = boardState[r][c];
      if(p && p.color === color){
        for(let dr=0; dr<8; dr++){
          for(let dc=0; dc<8; dc++){
            if(isValidMove(r,c,dr,dc)) return true;
          }
        }
      }
    }
  }
  return false;
}

/* Инициализация (пустая доска в меню) */
initBoardState();
renderBoard();
</script>
</body>
</html>
